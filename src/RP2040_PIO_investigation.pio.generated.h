// -------------------------------------------------- //
// This file is autogenerated by pioasm; do not edit! //
// -------------------------------------------------- //

#pragma once

#if !PICO_NO_HARDWARE
#include "hardware/pio.h"
#endif

// ------- //
// qdecpio //
// ------- //

#define qdecpio_wrap_target 0
#define qdecpio_wrap 9

#define qdecpio_offset_pin_starts_high 0u
#define qdecpio_offset_pin_starts_low 5u

static const uint16_t qdecpio_program_instructions[] = {
            //     .wrap_target
    0x2020, //  0: wait   0 pin, 0                   
    0x00c4, //  1: jmp    pin, 4                     
    0x0045, //  2: jmp    x--, 5                     
    0x0005, //  3: jmp    5                          
    0x0085, //  4: jmp    y--, 5                     
    0x20a0, //  5: wait   1 pin, 0                   
    0x00c9, //  6: jmp    pin, 9                     
    0x0080, //  7: jmp    y--, 0                     
    0x0000, //  8: jmp    0                          
    0x0040, //  9: jmp    x--, 0                     
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program qdecpio_program = {
    .instructions = qdecpio_program_instructions,
    .length = 10,
    .origin = -1,
};

static inline pio_sm_config qdecpio_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + qdecpio_wrap_target, offset + qdecpio_wrap);
    return c;
}

static inline void qdecpio_program_init(PIO pio, int smIdx, uint offset, uint pin_a, uint pin_b) {
    pio_sm_config config = qdecpio_program_get_default_config(offset);
    sm_config_set_in_pins(&config, pin_a); // sm will wait on edges on this pin's signal
    sm_config_set_jmp_pin(&config, pin_b); // sm will conditionally jump based on this pin's signal
    // static const bool shift_direction_right = false;
    // static const bool enable_autopush       = true;
    // static const uint8_t autopush_threshold = 32;
    sm_config_set_in_shift(&config, false, true, 32);
    pio_sm_init(pio, smIdx, offset, &config);
    // static init here ... saves 2 instructions
    // NOTE: technically, this is not required, as caller must cache old values
    //       to detect offsets (movement) ... just easier to debug.
    pio_sm_exec_wait_blocking(pio, smIdx, pio_encode_set(pio_y, 0));
    pio_sm_exec_wait_blocking(pio, smIdx, pio_encode_set(pio_x, 0));
    // Allow choice: when at rest, start by waiting for Pin
    bool first_wait_for_high = digitalRead()
    uint start_offset = offset;
    start_offset += first_wait_for_high ? qdecpio_offset_pin_starts_low : qdecpio_offset_pin_starts_high;
    pio_sm_exec_wait_blocking(pio, smIdx, pio_encode_jmp(start_offset));
    // finally, start execution of the state machine
    pio_sm_set_enabled(pio, smIdx, true);
}
// helper functions to allocate available PIO & State Machine.
typedef struct {            // Valid only if `pio != nullptr`
    PIO pio;                // will be nullptr on failure
    uint programOffset;
    int stateMachineIdx;
} allocated_pio_sm_program;
static const allocated_pio_sm_program invalid_pio_sm_program_allocation = {
    .pio = nullptr,
    .programOffset = (uint)-1,
    .stateMachineIdx = -1,
};
static inline allocated_pio_sm_program qdecpio_try_to_allocate_specific_pio(PIO pio) {
    if (!pio_can_add_program(pio, &qdecpio_program)) {
        return invalid_pio_sm_program_allocation;
    }
    int smIdx = pio_claim_unused_sm(pio, false); // false == return -1 on failure (not panic)
    if (smIdx == -1) {
        return invalid_pio_sm_program_allocation;
    }
    // No more failures paths from here onwards
    uint offset = pio_add_program(pio, &qdecpio_program); // panics on failure
    allocated_pio_sm_program x = {
        .pio = pio,
        .programOffset = offset,
        .stateMachineIdx = smIdx,
    };
    return x;
}
static inline allocated_pio_sm_program qdecpio_try_to_initialize(uint pin_a, uint pin_b) {
    allocated_pio_sm_program x = qdecpio_try_to_allocate_specific_pio(pio0);
    if (x.pio == nullptr) {
        x = qdecpio_try_to_allocate_specific_pio(pio1);
    }
    if (x.pio != nullptr) {
        qdecpio_program_init(x.pio, x.stateMachineIdx, x.programOffset, pin_a, pin_b);
    }
    return x;
}

#endif

